# 인간형 코어 브레인 메모리 · 구조 설계서 (v1.0)

> **목표**  
> “장난감 뇌”가 아니라,  
> **물리량을 가진 진짜 뉴런·시냅스 + 인간 뇌 구조 원리**를 따르는 **코어 브레인**을  
> TB~PB 메모리 없이, **수십 GB 이하 수준**에서 구현하는 설계의 완결판.

---

## 0. 전체 그림 요약

### 0.1 코어 브레인 목표 스펙

- 뉴런 수  
  \[
  N_n \approx 10^8 \quad (\text{1억 개})
  \]
- 시냅스 수  
  \[
  N_s \approx 10^{11} \quad (\text{1,000억 개})
  \]
- 뉴런 모델  
  - Hodgkin–Huxley(HH) 계열 스파이킹 뉴런
  - 막전위, 이온 채널, 게이트 변수 포함
- 시냅스 모델  
  - 전도도(conductance) 기반 시냅스
  - STDP(Spike-Timing-Dependent Plasticity) 로컬 학습 규칙
- 구조(Topology)  
  - 인간 피질(cortex) 구조를 축소한 **minicolumn / macrocolumn 패턴**
  - 완전연결이 아닌 **희소(sparse)** 연결
- Embodiment  
  - MuJoCo / 로봇 환경과 연결
  - 감각 입력 → 뉴런 외부 전류 / 모터 출력 → 로봇 토크

---

## 1. 뉴런 모델: Hodgkin–Huxley 계열

### 1.1 기본 수식

막전위 \(V(t)\) 에 대한 HH 방정식:

\[
C_m \frac{dV}{dt} = -\sum_i g_i(V - E_i) + I_\text{syn}(t) + I_\text{ext}(t)
\]

- \(C_m\): 막 용량 [F]
- \(V\): 막 전위 [V]
- \(g_i\): 채널별 전도도 [S]
- \(E_i\): 채널별 역전위 [V]
- \(I_\text{syn}\): 시냅스 전류 합 [A]
- \(I_\text{ext}\): 외부 자극 전류 [A]

일반적인 3채널(나트륨, 칼륨, 누설) HH:

\[
g_\text{Na} = \bar{g}_\text{Na} m^3 h,\quad
g_\text{K} = \bar{g}_\text{K} n^4,\quad
g_\text{L} = \bar{g}_\text{L}
\]

\[
C_m \frac{dV}{dt} = - g_\text{Na}(V-E_\text{Na})
- g_\text{K}(V-E_\text{K})
- g_\text{L}(V-E_\text{L})
+ I_\text{syn} + I_\text{ext}
\]

게이트 변수 \(x \in \{m,h,n\}\):

\[
\frac{dx}{dt} = \alpha_x(V)\,(1-x) - \beta_x(V)\,x
\]

혹은 \(\tau\)–\(x_\infty\) 형태:

\[
\frac{dx}{dt} = \frac{x_\infty(V) - x}{\tau_x(V)}
\]

---

### 1.2 뉴런 상태 변수와 메모리

**필수 상태 변수(최소 구성)**

| 기호 | 의미 | 단위 | 타입 | 개수 |
|------|------|------|------|------|
| \(V\) | 막 전위 | V | float32 | 1 |
| \(m,h,n\) | 게이트 변수 | - | float32 | 3 |
| \(I_\text{syn}\) | 시냅스 전류 합 | A | float32 | 1 |
| \(t_\text{spike}\) | 마지막 스파이크 시간 | s | float32 | 1 |
| 기타 버퍼 | 보조(예: 누적전류) | - | float32 | 2 |

가정: **총 8개 float32**

- 1 float32 = 4 bytes
- 뉴런당 상태 메모리  
  \[
  B_n = 8 \times 4 \;\text{bytes} = 32 \,\text{bytes}
  \]

\[
M_n = N_n \cdot B_n
\]

코어 브레인 기준:

\[
M_n = 10^8 \times 32 \approx 3.2 \times 10^9 \,\text{bytes} \approx 3.2 \,\text{GB}
\]

---

## 2. 시냅스 모델: Conductance + STDP

### 2.1 시냅스 전류

단일 시냅스 전류:

\[
I_\text{syn}(t) = g(t)\,(V(t) - E_\text{syn})
\]

- \(g(t)\): 시냅스 전도도 [S]
- \(E_\text{syn}\): 시냅스 역전위 [V]

전도도 동역학(지수 감쇠 + 프리 스파이크 입력):

\[
\frac{dg}{dt} = -\frac{g}{\tau_\text{syn}} + \sum_k w \,\delta(t - t_k^\text{pre})
\]

- \(\tau_\text{syn}\): 시냅스 시간 상수 [s]
- \(w\): 최대 전도도(시냅스 weight 역할) [S]
- \(t_k^\text{pre}\): 프리 뉴런 k번째 스파이크 시간 [s]

---

### 2.2 STDP (Spike-Timing-Dependent Plasticity)

프리/포스트 스파이크 시간 차 \(\Delta t = t_\text{post} - t_\text{pre}\) 에 따라:

\[
\Delta w =
\begin{cases}
A_+ \exp\left(-\frac{\Delta t}{\tau_+}\right) & \Delta t > 0 \\
-A_- \exp\left( \frac{\Delta t}{\tau_-} \right) & \Delta t < 0
\end{cases}
\]

- \(A_+\), \(A_-\): LTP/LTD 크기 [S]
- \(\tau_+\), \(\tau_-\): 시간 상수 [s]

실시간 구현을 위해 **trace** 사용:

- 프리 trace: \(x_\text{pre}\)
- 포스트 trace: \(x_\text{post}\)

\[
\frac{dx_\text{pre}}{dt} = -\frac{x_\text{pre}}{\tau_+} + \sum_k \delta(t - t_k^\text{pre})
\]
\[
\frac{dx_\text{post}}{dt} = -\frac{x_\text{post}}{\tau_-} + \sum_k \delta(t - t_k^\text{post})
\]

업데이트 규칙(이산형):

- 프리 스파이크 발생 시:
  \[
  \Delta w = A_- x_\text{post}
  \]
- 포스트 스파이크 발생 시:
  \[
  \Delta w = A_+ x_\text{pre}
  \]

---

### 2.3 시냅스 상태 변수와 메모리 (압축 전)

**필수 상태 변수**

| 기호 | 의미 | 단위 | 타입 | 개수 |
|------|------|------|------|------|
| \(w\) | 시냅스 weight / g_max | S | float32 | 1 |
| \(g\) | 현재 전도도 | S | float32 | 1 |
| \(x_\text{pre}\) | 프리 trace | - | float32 | 1 |
| \(x_\text{post}\) | 포스트 trace | - | float32 | 1 |
| delay | 전도 지연 | s | float32 | 1 |
| meta | type/flag 등 | - | float32 (또는 int32) | 1 |

합: **6개 float32 ≈ 24 bytes/시냅스**  
(이 24 bytes를 **기본값 \(B_s\)** 로 둔다.)

코어 브레인 기준 시냅스 메모리:

\[
M_s = N_s \cdot B_s
= 10^{11} \times 24
= 2.4 \times 10^{12} \,\text{bytes}
\approx 2.4 \,\text{TB}
\]

---

## 3. 기본 메모리 총합 (압축 전)

\[
M_\text{total} = M_n + M_s
\approx 3.2\,\text{GB} + 2.4\,\text{TB}
\approx 2.4\,\text{TB}
\]

즉, **정직한 HH + STDP 네트워크(1억 뉴런, 1,000억 시냅스)** 는  
그냥 두면 **약 2.4 TB** 메모리가 필요하다.

---

## 4. 메모리 절감 원리 (6가지 축)

압축 후 per-neuron, per-synapse 메모리를 \(B_n', B_s'\) 라고 할 때:

\[
M_\text{total}' = N_n B_n' + N_s B_s'
\]

각 기술이 \(B_n, B_s\) 에 어떻게 영향을 주는지 정량화한다.

---

### 4.1 Quantization (bit 수 줄이기)

#### 원리

- float32 → float16 / int8 / int4 / 1bit 등으로 감소
- weight와 trace는 **고정밀도가 필요 없음**
- 거시적 동작(attractor, 패턴 인식)은 낮은 bit에서도 보존 가능

#### 수식

- weight bit 수: \(b_w\)
- trace bit 수: \(b_x\)

weight / trace 메모리:

\[
B_\text{float32} = 3 \times 32\,\text{bit} = 96\,\text{bit} = 12\,\text{bytes}
\]
\[
B_\text{quant} = b_w + 2b_x \quad (\text{bit 단위})
\]

예시 (모두 8bit 사용):

\[
B_\text{quant} = 8 + 2\times 8 = 24\,\text{bit} = 3\,\text{bytes}
\]

나머지 g, delay, meta 합쳐서 5 bytes 정도라고 하면,

- 기존 \(B_s = 24\) bytes
- 새 \(B_s^\text{(quant)} \approx 3 + 5 = 8\) bytes

압축률:

\[
r_s^\text{(quant)} = \frac{24}{8} = 3
\]

---

### 4.2 Event-driven + 활성/비활성 시냅스 분리

#### 원리

- 실제 스파이킹 네트워크는 대부분 시간에 **스파이크가 없음**
- 일정 시간 동안 변동이 거의 없는 시냅스는 **비활성(inactive)** 으로 보고,
  - full state가 아니라 **압축된 최소 정보**만 유지
- 활성(active) 시냅스만 full state 유지

#### 모델링

- 활성 비율: \(\rho \in [0,1]\)
- 활성 시냅스 상태 메모리: \(B_s^\text{active}\)
- 비활성 시냅스 상태 메모리: \(B_s^\text{inactive}\)

평균 시냅스 메모리:

\[
B_s' = \rho B_s^\text{active} + (1-\rho) B_s^\text{inactive}
\]

예시:

- quantization 후 full state: \(B_s^\text{active} = 8\) bytes
- 비활성은 kernel ID 1 byte + 간단 flag 0 byte → \(B_s^\text{inactive} = 1\) byte
- 활성 시냅스 비율: \(\rho = 0.1\) (10%)

\[
B_s' = 0.1 \times 8 + 0.9 \times 1 = 0.8 + 0.9 = 1.7\,\text{bytes}
\]

압축률(기본 24bytes 대비):

\[
r_s^\text{(event)} = \frac{24}{1.7} \approx 14
\]

---

### 4.3 Synapse Kernelization (구조 공유)

#### 원리

- 뇌는 **minicolumn, microcircuit** 등 반복 패턴 존재
- “시냅스 패턴 + 파라미터”를 **kernel** 로 정의하고,
  - 실제 시냅스는 “kernel ID + local index” 정도만 저장
- **kernel 개수 \(K\)** 는 전체 시냅스 수 \(N_s\) 보다 훨씬 작음

#### 수식

- kernel 파라미터 메모리: \(M_\text{kernel} \propto K\)
- per-synapse 구조 정보:  
  - kernel ID: \(\lceil \log_2 K \rceil\) bit
  - local index: \(\lceil \log_2 L \rceil\) bit (\(L\): kernel당 시냅스 수)

예: \(K = 256\) (1 byte), \(L \le 65536\) (2 bytes)

\[
B_s^\text{kernel-id} \approx 3\,\text{bytes}
\]

event-driven 모델과 합치면:

- active: 여전히 6~8 bytes 수준
- inactive: kernel ID 1 byte (필요시 local index 포함해 2~3 bytes)

구조 전체를 위해 별도의 adjacency list를 둘 필요가 없으므로,  
**구조 메모리는 \(O(K)\)** 로 내려감 (실질적으로 MB 단위).

---

### 4.4 Procedural Connectivity (절차적 연결 생성)

#### 원리

- “시냅스 리스트” 자체를 저장하지 않고,  
  \[
  \text{connected}(i,j) = \mathbb{1}\big(R(i,j;\theta) > \tau\big)
  \]
  형태의 함수로 결정
- \(R\): 거리, layer, column, type 등을 고려한 점수 함수
- \(\theta\): 몇 개 안 되는 파라미터 벡터

#### 효과

- 원래는 pre/post index 쌍을 **\(N_s\) 개 저장**해야 했지만,
- 이제는 \(\theta\) + 함수 정의만 있으면 됨 → **상수 메모리**

즉, 연결 구조 저장에 필요한 메모리:

\[
M_\text{connectivity} \sim O(\text{len}(\theta)) \ll O(N_s)
\]

이것은 **구조 메모리를 사실상 0에 가깝게** 만든다.

---

### 4.5 Developmental Rules (발달 알고리즘, “DNA 스타일”)

#### 원리

- 실제 뇌는 connectome 전체를 저장하지 않고,  
  **발생/발달 규칙**(DNA + 발달 과정)을 통해 구조를 생성
- 우리는 “genome” 벡터를 정의하고,
  \[
  \theta = f(\text{genome})
  \]
  \[
  \text{connectome} = g(\theta)
  \]
  처럼 **두 단계 생성**으로 모델링

#### 메모리

- genome: 수십 KB ~ 수 MB
- \(f, g\): 코드 + 소수의 파라미터 (MB 이하)
- 전체 connectome 구조를 별도 파일로 저장할 필요 없음

\[
M_\text{development} \approx \text{MB 수준}
\]

---

### 4.6 뉴런 압축 (float16, coarse-grain 등)

#### 방법

1. **정밀도 감소**
   - 뉴런 상태 변수 8개를 float16으로 저장
   \[
   B_n' = 8 \times 2 = 16\,\text{bytes}
   \]
   → 2배 절약

2. **Coarse-graining (집단 뉴런)**
   - 뉴런 100개를 “집단 뉴런 하나”로 묶어 평균 firing/state 사용
   - 실제 뉴런 수 \(N_n\) 을 10배~100배 줄일 수 있음
   - 다만, 너무 심하면 미시적 구조가 희석되므로 **“기능적 지능 유지가 가능한 최소 축소”**를 목표로.

---

## 5. 압축 조합별 메모리 시나리오

코어 브레인 가정:

- \(N_n = 10^8\)
- \(N_s = 10^{11}\)

---

### 5.1 시나리오 A – 보수적 (기능 완전 유지, 구현 난이도 낮음)

- quantization: 24B → 8B (3×)
- event-driven: 활성률 \(\rho = 0.1\)
- inactive: 4B (간단한 최소 상태)
- kernelization/절차적/발달: **구조 메모리만 줄임**, per-synapse 상태는 여전히 존재

\[
B_s' = 0.1 \times 8 + 0.9 \times 4 = 4.4\,\text{bytes}
\]

\[
r_s \approx \frac{24}{4.4} \approx 5.4
\]

- 시냅스 메모리:
  \[
  M_s' = 10^{11} \times 4.4 \approx 4.4 \times 10^{11}
  \,\text{bytes} \approx 410\,\text{GB}
  \]

- 뉴런 메모리는 3.2GB 그대로 사용

**합:**

\[
M_\text{total}' \approx 413\,\text{GB}
\]

> **2.4TB → 약 0.4TB (약 6배 감소)**

---

### 5.2 시나리오 B – 현실적인 타깃 (실제 구현 가능 + 메모리 크게 절약)

- weight, trace: 8bit
- full active state: \(B_s^\text{active} = 6\) bytes
- inactive state: \(B_s^\text{inactive} = 1\) byte
- 활성률: \(\rho = 0.05\) (5%)

\[
B_s' = 0.05 \times 6 + 0.95 \times 1 = 0.3 + 0.95 = 1.25\,\text{bytes}
\]

\[
r_s \approx \frac{24}{1.25} = 19.2
\]

- 시냅스 메모리:
  \[
  M_s' = 10^{11} \times 1.25 = 1.25 \times 10^{11}\,\text{bytes} \approx 116\,\text{GB}
  \]

- 뉴런: float16 사용  
  \[
  B_n' = 16\,\text{bytes} \Rightarrow 
  M_n' = 10^{8} \times 16 = 1.6 \times 10^{9}
  \approx 1.6\,\text{GB}
  \]

**합:**

\[
M_\text{total}' \approx 116\,\text{GB} + 1.6\,\text{GB} \approx 118\,\text{GB}
\]

> **현실적 목표: 2.4TB → 약 100GB대**

---

### 5.3 시나리오 C – 극단적(기능 위주, 미시적 정보 상당 부분 희생)

- block-level plasticity: 시냅스 무리(예: 1024개)에 하나의 trace/파라미터 공유
- per-synapse 실시간 상태를 **2비트** 수준으로 압축
- 구조/파라미터는 완전히 kernel + 발달 규칙으로 넘김

가정:

- per-synapse 실시간 상태:  
  \[
  B_s' = 0.25\,\text{bytes} \quad (2\,\text{bits} \times 1\,\text{byte 정렬 등 고려)
  \]

코어 브레인(1e8, 1e11) 기준:

\[
M_s' = 10^{11} \times 0.25 = 2.5 \times 10^{10}\,\text{bytes}
\approx 23\,\text{GB}
\]

뉴런 메모리(1~2GB)를 합치면:

\[
M_\text{total}' \approx 25\,\text{GB}
\]

더 축소된 코어 브레인 (예: \(N_n=10^7, N_s=10^{10}\)) 으로 가면:

\[
M_s' = 10^{10} \times 0.25 = 2.5 \times 10^9 \approx 2.3\,\text{GB}
\]
\[
M_n' \approx 0.16\,\text{GB}
\Rightarrow M_\text{total}' \approx 2.5\,\text{GB}
\]

> **극단적 설계: 몇 GB 이하, 이론상 수백 MB까지 가능**

---

## 6. “성능은 그대로인가?”에 대한 정리

- **Quantization**
  - 미시적 값(정확한 weight, trace)은 바뀌지만
  - attractor 구조, 패턴 인식, 학습 가능한지 같은 **거시적 기능**은 대부분 유지
- **Event-driven**
  - 실제 뇌도 스파이크 없으면 멈춘 상태에 가까움 → **더 뇌스러움**
- **Kernelization / Procedural / Developmental**
  - 뇌 자체가 **규칙 기반 발달**을 통해 구조를 만든다
  - 우리는 “데이터 구조를 그대로 저장”하는 대신 “규칙을 저장” → 원리적으로 뇌와 더 유사
- **Block-level plasticity**
  - 시냅스 개별 차원 정보는 잃지만
  - “어떤 회로가 강화/약화되는가”라는 기능은 유지

> **정리**  
> - “각 시냅스·뉴런 상태를 완벽하게 똑같이 재현”하는 건 포기  
> - 대신 **학습·기억·행동 생성이라는 기능적 레벨**은 유지 가능  
> - 그리고 이 방향이 실제 뇌 구현 방식에도 더 가깝다.

---

## 7. ABI/IZG에 적용하는 개발 계획 (Stage 설계)

### Stage N0 – HH 뉴런 + STDP 시냅스 기본 구현

- 파일:  
  - `brain_core/neuron/compartment.py`  
  - `brain_core/synapse/synapse_biophys.py`
- 할 일:
  - LIF/단순 모델 → HH 계열 공식으로 교체
  - conductance-based synapse + STDP trace 구현
  - 단일 뉴런, 뉴런 2개 + 시냅스 테스트 (스파이크, STDP 학습 확인)
- 테스트:
  - DC 전류 입력 → 정상적인 HH 스파이크 train 발생
  - 반복 자극 → STDP에 따라 weight 변화 방향 검증

---

### Stage N1 – Quantization + Event-driven 엔진

- 상태 표현:
  - 뉴런 상태: float16 (혹은 일부 변수만 8bit)
  - 시냅스 weight, trace: 8bit
- 시뮬레이션 루프:
  - 모든 시냅스를 매 step 업데이트하지 않고,
  - “스파이크 발생 시 이벤트 큐 기반으로 전파”
- 활성/비활성 상태:
  - 시냅스의 trace/g가 거의 0일 때 inactive로 전환
  - inactive 상태는 1byte만 유지 (kernel ID + flag)

목표:

- 소형 네트워크로 메모리/속도 이득을 직접 측정
- 나중에 대규모 스케일로 extrapolation 가능하게 데이터 확보

---

### Stage N2 – Microcircuit Kernel 설계 + Kernelization

- cortex 문헌 기반으로 **minicolumn kernel** 정의
  - 예: excitatory 80%, inhibitory 20%
  - layer 구조, feedforward/feedback 패턴 등
- kernel 구조:
  - 내부 뉴런 수, 시냅스 연결 패턴, weight 분포 파라미터
- 전체 네트워크 생성:
  - grid 상에 minicolumn/macrocolumn 배치
  - 각 column은 kernel의 인스턴스

결과:

- 전체 구조는 “column 좌표 + kernel ID”로 표현
- 시냅스 개별 구조는 생성 함수로부터 필요할 때만 계산

---

### Stage N3 – Procedural Connectivity + 발달 규칙

- 함수 \(R(i,j;\theta)\) 설계:
  - 거리 기반 연결, layer 규칙, type별 연결 확률 포함
- genome-like 파라미터 벡터 정의:
  - column 밀도, layer 비율, 연결 확률 등
- 발달 알고리즘:
  - 초기 seed → column 생성
  - 성장, pruning, activity-dependent 강화 규칙 포함 가능

이 단계 이후:

- **connectome 전체를 파일로 저장하지 않고도**  
  동일한 구조를 재생성 가능
- 저장해야 할 것은 genome(파라미터 셋) 뿐

---

### Stage N4 – Embodiment 연동

- MuJoCo / 로봇 환경에서:
  - 관절 각도/속도, 센서 → 뉴런 외부 전류 \(I_\text{ext}\) 로 인코딩
  - 모터 뉴런 집단 firing → 토크/행동으로 디코딩
- 보상/강화:
  - reward-modulated STDP (도파민 역할 신호) 도입
  - 특정 행동 패턴이 강화되는지 실험

이때 관찰 포인트:

- self-organized policy 생성 여부
- 환경 변화에 대한 적응
- 메모리/학습 성능과 네트워크 크기의 관계

---

### Stage N5 – 스케일 업 및 메모리 프로파일링

- 네트워크 크기 단계별 증가:
  - \(N_n=10^5 \to 10^6 \to 10^7 \to 10^8\)
- 각 단계에서:
  - 실제 메모리 사용량 측정
  - 시나리오 A/B/C 어디 근처에 위치하는지 확인
- 병렬화:
  - GPU/CPU hybrid
  - 분산 시뮬레이션 구조 설계

목표:

- “이 설계대로 구현했을 때, 어느 지점까지 확장 가능?”을 실제 수치로 검증
- 필요시 block-level plasticity, 더 강한 quantization 등 추가 도입

---

## 8. 최종 한줄 요약

> 인간형 코어 브레인을 **처음부터 진짜(HH + STDP + 피질 구조)** 로 만들되,  
> 시냅스/뉴런의 표현 방식을  
> **정밀도 축소 · event-driven · kernel 공유 · 절차적 생성 · 발달 규칙** 으로 바꾸면,  
> 원래 **TB~PB급**이 필요하던 시스템을  
> 설계에 따라 **수십~수백 GB**, 극단적으로는 **수 GB ~ 수백 MB** 수준까지  
> 줄이면서도, 우리가 원하는 **학습·기억·행동**이라는 기능적 수준의 성능은  
> 그대로 유지할 수 있다.

---
